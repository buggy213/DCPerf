[uwsgi]
# Proxygen + uWSGI Configuration for DjangoBench V2
#
# Architecture:
#   uWSGI: Process management, memory cleanup, monitoring
#   Proxygen: Async HTTP server (started in each worker via postfork hook)
#   Django: ASGI application
#
# Each uWSGI worker process starts its own Proxygen server instance
# that handles HTTP requests asynchronously using multiple threads.

# ============================================
# Process Management
# ============================================
master = True
processes = %(workers)
workers = %k
lazy-apps = True

# Load proxygen_wsgi to register postfork hooks
# Use wsgi-file to directly load the Python file
wsgi-file = proxygen_wsgi.py

# Enable threads for Python (needed for Proxygen's threading)
enable-threads = True

# ============================================
# Socket Configuration
# ============================================
# uWSGI requires a socket to start, even if not actively used
# We use a Unix socket for uWSGI master communication
# Proxygen handles all actual HTTP traffic on its own port
socket = /tmp/uwsgi-proxygen.sock
chmod-socket = 666

# Keep socket for graceful reloads
vacuum-socket = true

# ============================================
# Memory Management and Cleanup
# ============================================
# Reload worker if RSS memory exceeds 1GB
reload-on-rss = 1000

# Force reload if RSS memory exceeds 1.5GB
evil-reload-on-rss = 1500

# Maximum request execution time (seconds)
harakiri = 75

# Time to wait for graceful shutdown
reload-mercy = 15
worker-reload-mercy = 15

# Clean up on exit
vacuum = True

# ============================================
# Concurrency and Threading
# ============================================
# Lock engine for thread safety
lock-engine = ipcsem
persistent-ipcsem = 1

# Note: Proxygen handles threading internally
# Each worker process runs one Proxygen server with multiple threads

# ============================================
# Python Optimization
# ============================================
# Disable Python garbage collection for performance
# (Django and Proxygen manage memory efficiently)
disable-gc = True

# NUMA-aware forking
numa-fork = True

# Call os.fork hooks after forking
py-call-osafterfork = True

# Python optimization level
optimize = 2

# ============================================
# Logging and Monitoring
# ============================================
# Stats server for monitoring
stats = 127.0.0.1:9191

# Log to file
logger = file:django-proxygen-uwsgi.log

# Log worker lifecycle events
log-master = True

# ============================================
# Environment Variables (Examples)
# ============================================
# Set these in your environment or override here:
#   PROXYGEN_IP=0.0.0.0
#   PROXYGEN_PORT=8000
#   PROXYGEN_THREADS=0  (0 = auto-detect CPU cores)
#   DJANGO_SETTINGS_MODULE=django_workload.settings
env= DJANGO_SETTINGS_MODULE=cluster_settings
